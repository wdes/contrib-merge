#!/usr/bin/env php
<?php

/**
 * @version 1.5.0
 */

final class ContribMerge {
    private static string $OWNER = '';
    private static string $REPO = '';

    public static function run(array $options) {
        if (! isset($options['pr']) || empty($options['pr'])) {
            echo 'Use: contrib-merge --pr 123' . PHP_EOL;
            echo 'Use: contrib-merge --pr 123 --changelog' . PHP_EOL;
            echo 'Use: contrib-merge --pr 123 --merge' . PHP_EOL;
            echo 'Use: contrib-merge --pr 1 --owner williamdes --repo test-repo --merge' . PHP_EOL;
            echo 'Use: contrib-merge --pr 1 --org sudo-bot --repo action-docker-sign --merge' . PHP_EOL;
            exit(1);
        }

        if (isset($options['owner']) && ! empty($options['owner'])) {
            self::$OWNER = $options['owner'];
        }
        if (isset($options['org']) && ! empty($options['org'])) {
            self::$OWNER = $options['org'];
        }
        if (isset($options['repo']) && ! empty($options['repo'])) {
            self::$REPO = $options['repo'];
        }

        // Try to auto detect
        if (empty(self::$OWNER) && empty(self::$REPO)) {
            $repoPath = getcwd();
            $gitRemoteOrigin = shell_exec(
                <<<SH
                cd '$repoPath';
                git remote get-url origin;
                SH
            );
            if (! empty($gitRemoteOrigin)) {
                $matches = [];
                $regexGitUrl = '/(?<org>[a-z0-9_-]+)\/(?<repo>[a-z0-9_-]+)(:?\.git$|$)/i';
                preg_match_all($regexGitUrl, $gitRemoteOrigin, $matches);

                self::$OWNER = $matches['org'][0] ?? '';
                self::$REPO = $matches['repo'][0] ?? '';
                if (empty(self::$OWNER) || empty(self::$REPO)) {
                    echo 'Unable to auto detect the slug from remote URL: ' . $gitRemoteOrigin . PHP_EOL;
                } else {
                    echo '--Auto detected settings--' . PHP_EOL;
                    echo 'Owner/org: ' . self::$OWNER . PHP_EOL;
                    echo 'Repo: ' . self::$REPO . PHP_EOL;
                    echo '--Auto detected settings--' . PHP_EOL;
                }
            }
        }


        if (empty(self::$OWNER) || empty(self::$REPO)) {
            echo 'Missing repo or owner/org' . PHP_EOL;
            echo 'Owner/org: ' . self::$OWNER . PHP_EOL;
            echo 'Repo: ' . self::$REPO . PHP_EOL;
            exit(1);
        }

        echo 'Slug: ' . self::$OWNER . '/' . self::$REPO . PHP_EOL;
        $changeLogMode = isset($options['changelog']);
        $mergeMode = isset($options['merge']);
        $prId = $options['pr'];
        match ($changeLogMode) {
            true => self::changeLogPr($prId),
            false => self::mergePr($prId, $mergeMode),
        };
    }

    private static function getIssue(int $issueId): array
    {
        return self::ghAPI(
            sprintf(
                '/repos/%s/%s/issues/%s',
                self::$OWNER,
                self::$REPO,
                $issueId
            )
        );

    }

    private static function changeLogPr(int $prId): void
    {
        $prData = self::ghAPI(
            sprintf(
                '/repos/%s/%s/pulls/%s',
                self::$OWNER,
                self::$REPO,
                $prId
            )
        );

        echo 'Title: ' . $prData['title'] . PHP_EOL;
        $links = self::getLinks($prData['body']);
        echo '--Fixes--' . PHP_EOL;
        foreach ($links['fixes'] as $issueId) {
            $issueData = self::getIssue($issueId);
            echo '- issue #' . $issueId . ' ' . $issueData['title'] . PHP_EOL;
        }
        echo '--Closes--' . PHP_EOL;
        foreach ($links['closes'] as $issueId) {
            $issueData = self::getIssue($issueId);
            echo '- issue #' . $issueId . ' ' . $issueData['title'] . PHP_EOL;
        }
    }

    private static function mergePr(int $prId, bool $doMerge): void
    {
        $prData = self::ghAPI(
            sprintf(
                '/repos/%s/%s/pulls/%s',
                self::$OWNER,
                self::$REPO,
                $prId
            )
        );

        //var_dump($prData['head']);
        echo 'By: ' . $prData['head']['user']['login'] . ' (' . $prData['author_association'] . ')' . PHP_EOL;
        echo 'Stats: commits: ' . $prData['commits']
            . ', add: ' . $prData['additions']
            . ', del: ' . $prData['deletions']
            . ', mod: ' . $prData['changed_files']
            . PHP_EOL;
        echo 'Title: ' . $prData['title'] . PHP_EOL;
        echo 'Body: ' . PHP_EOL . $prData['body'] . PHP_EOL;
        $links = self::getLinks($prData['body'] ?? '');
        $specialMentions = '';
        foreach ($links['fixes'] as $issueId) {
            $specialMentions .= 'Fixes: #' . $issueId . PHP_EOL;
        }
        foreach ($links['closes'] as $issueId) {
            $specialMentions .= 'Closes: #' . $issueId . PHP_EOL;
        }
        foreach ($links['custom'] as $linkName => $links) {
            foreach ($links as $link) {
                $specialMentions .= $linkName . ': ' . $link . PHP_EOL;
            }
        }
        $remoteName = $prData['head']['user']['login'];

        $mergeRemoteUrl = $prData['head']['repo']['ssh_url'];
        $baseRemoteUrl = $prData['base']['repo']['ssh_url'];
        $branchMergedIntoRef = $prData['base']['ref'];
        $branchRef = $prData['head']['ref'];
        $branchShaRef = $prData['head']['sha'];

        $mergeRef = self::addRemoteIfMissingAndFetch(
            $baseRemoteUrl,
            $mergeRemoteUrl,
            $remoteName,
            $branchRef,
            $branchShaRef,
            $prId
        );
        $prTitle = $prData["title"];
        $mergeMsg = <<<MD
        Merge #$prId - $prTitle

        Pull-request: #$prId
        $specialMentions

        MD;

        $repoPath = getcwd();
        if ($doMerge === false) {
            echo 'Branch ' . $mergeRef . PHP_EOL;
            echo 'Merge message: ' . PHP_EOL;
            echo 'Merge template: ' . PHP_EOL;
            echo $mergeMsg;
        }
        if ($doMerge) {
            if ($prData['merged']) {
                echo 'Already merged ! ' . PHP_EOL;
                exit(1);
            }
            $isRepoClean = trim(shell_exec(
                <<<SH
                cd '$repoPath';
                git status --porcelain;
                SH
            ) ?? '');
            if ($isRepoClean !== '') {
                echo 'The repository is not clean ! ' . PHP_EOL;
                exit(1);
            }
            $currentBranch = trim(shell_exec(
                <<<SH
                cd '$repoPath';
                git branch --show-current;
                SH
            ) ?? '');

            if ($currentBranch !== $branchMergedIntoRef) {
                echo 'The current branch is not the branch ' . $branchMergedIntoRef . ' ! ' . PHP_EOL;
                exit(1);
            }

            echo 'Merging branch ' . $mergeRef . ' into ' . $branchMergedIntoRef . PHP_EOL;
            $mergeMsg = escapeshellarg($mergeMsg);
            $signoff = trim(shell_exec(
                <<<SH
                cd '$repoPath';
                git config format.signoff;
                SH
            ) ?? '');

            $signoffOption = $signoff !== 'false' ? '--signoff' : '';
            $gitRemotes = shell_exec(
                <<<SH
                cd '$repoPath';
                git merge '$mergeRef' --no-ff $signoffOption -m $mergeMsg;
                SH
            );
        }
    }

    /**
     * @param string $baseRemoteUrl The repo to merge into
     * @param string $mergeRemoteUrl The repo asking for the merge
     */
    private static function addRemoteIfMissingAndFetch(
        string $baseRemoteUrl, string $mergeRemoteUrl, string $remoteName, string $branchRef, string $branchShaRef, int $prId
    ): string
    {
        $repoPath = getcwd();

        // First strategy: check that refs/remotes/<origin_name>/pull/<pr_id>/head are fetched (and setup)

        $allPROrigins = <<<SH
        cd '$repoPath';
        LC_ALL=C.UTF-8 git show-ref | grep -P -- 'refs/remotes/.*/pull/'
        SH;
        $allPRsList = shell_exec($allPROrigins);

        // Do they have such refs ?
        if (trim($allPRsList) !== '') {
            // If the sha is not found in the output, then fetch all
            if (! str_contains($allPRsList, $branchShaRef)) {
                $prOrigins = <<<SH
                cd '$repoPath';
                git fetch -q;
                LC_ALL=C.UTF-8 git show-ref | grep -P -- 'refs/remotes/$prId/pull/'
                SH;
                $allPRsList = shell_exec($prOrigins);
            }

            $separator = "\n";
            $line = strtok($allPRsList, $separator);
            while ($line !== false) {
                # do something with $line
                $line = strtok($separator);
                if ($line === false) {
                    continue;
                }
                [$lineRemoteHash, $lineRemoteRef] = explode(" ", $line);

                if ($lineRemoteHash === $branchShaRef && str_contains($lineRemoteRef, '/pull/' . $prId)) {
                    echo 'Using ' . $lineRemoteRef . ' as the merge ref.' . PHP_EOL;
                    return $lineRemoteRef;
                }
            }
        }

        // Second strategy: find the remote in the list of remotes
        $findOriginCommand = <<<SH
        cd '$repoPath';
        LC_ALL=C.UTF-8 git remote -v
        SH;
        $gitRemoteOriginList = shell_exec($findOriginCommand);
        $gitRemoteOrigin = null;
        $separator = "\n";
        $line = strtok($gitRemoteOriginList, $separator);
        while ($line !== false) {
            # do something with $line
            $line = strtok($separator);
            if ($line === false) {
                continue;
            }
            [$lineRemoteName, $lineRemoteData] = explode("\t", $line);
            [$lineRemoteURL, $lineRemoteType] = explode(" ", $lineRemoteData);
            if ($lineRemoteType !== '(fetch)') {
                continue;
            }

            if ($lineRemoteURL === $mergeRemoteUrl || $lineRemoteURL === $mergeRemoteUrl . '.git') {
                return $lineRemoteName;
            }
        }

        // Fallback to finding "origin"
        if ($gitRemoteOrigin === null) {
            echo 'Unable to detect ' . $mergeRemoteUrl . ' using the "origin" remote instead ' . PHP_EOL;
            $gitRemoteOrigin = shell_exec(
                <<<SH
                cd '$repoPath';
                git remote get-url origin;
                SH
            );
        }

        // If the origin exists as "origin", then use it
        if ($gitRemoteOrigin === $mergeRemoteUrl || $gitRemoteOrigin === $mergeRemoteUrl . '.git') {
            $remoteName = 'origin';

            echo 'Fetching remote ' . $remoteName . PHP_EOL;
            shell_exec(
                <<<SH
                cd '$repoPath';
                git fetch $remoteName;
                SH
            );
            return $remoteName;
        }

        // Third strategy: add the remote and fetch it
        $gitRemotes = shell_exec(
            <<<SH
            cd '$repoPath';
            git remote -v;
            SH
        );
        echo 'Remote (' . $remoteName . '): ' . $mergeRemoteUrl . PHP_EOL;

        if (! str_contains($gitRemotes, $mergeRemoteUrl)) {
            echo 'Adding remote ' . $remoteName . PHP_EOL;
            shell_exec(
                <<<SH
                cd '$repoPath';
                git remote add $remoteName $mergeRemoteUrl;
                SH
            );
        }
        echo 'Fetching remote ' . $remoteName . PHP_EOL;
        shell_exec(
            <<<SH
            cd '$repoPath';
            git fetch $remoteName;
            SH
        );
        return $remoteName;
    }

    private static function getLinks(string $content): array
    {
        $reFixes = '/fixes(?:|:) #(\d+)/mi';
        $reCloses = '/closes(?:|:) #(\d+)/mi';
        $repoPath = getcwd();
        $contribMergeFromats = shell_exec(
            <<<SH
            cd '$repoPath';
            git config contrib-merge.format;
            SH
        );

        $customFormats = [];
        if (! empty($contribMergeFromats)) {
            $matches = [];
            preg_match_all($contribMergeFromats, $content, $matches, PREG_SET_ORDER);
            foreach ($matches as $match) {
                foreach ($match as $matchKey => $matchResult) {
                    if (is_numeric($matchKey)) {
                        continue;
                    }
                    if (! isset($customFormats[$matchKey])) {
                        $customFormats[$matchKey] = [];
                    }
                    $customFormats[$matchKey][] = trim($matchResult);
                }
            }
        }


        $matchesFixes = [];
        $matchesCloses = [];

        preg_match_all($reFixes, $content, $matchesFixes, PREG_PATTERN_ORDER);

        preg_match_all($reCloses, $content, $matchesCloses, PREG_PATTERN_ORDER);

        return [
            'fixes' => $matchesFixes[1],
            'closes' => $matchesCloses[1],
            'custom' => $customFormats,
        ];
    }

    private static function ghAPI(string $path, string $method = 'GET') {
        $currentDir = getcwd();
        $token = null;
        if ($currentDir && is_dir($currentDir)) {
            $token = shell_exec(
                <<<SH
                git config github.token
                SH
            );
        }
        if ($token !== null) {
            $token = trim($token);
            echo 'Using the token from the GitHub local config at: ' . $currentDir . PHP_EOL;
        }

        $headers = empty($token) ? [
                'Accept' => 'application/vnd.github+json',
                'X-GitHub-Api-Version' => '2022-11-28',
            ]
            :
            [
                'Authorization' => 'Bearer ' . $token,
                'Accept' => 'application/vnd.github+json',
                'X-GitHub-Api-Version' => '2022-11-28',
            ];

        $data = json_decode(self::makeRequest(
            'https://api.github.com' . $path,
            $headers,
            $method
        ), true);

        if (isset($data['status']) && ((int) $data['status']) !== 200) {
            echo 'Path: ' . $path . PHP_EOL;
            echo 'Headers: ' . json_encode($headers, JSON_PRETTY_PRINT | JSON_UNESCAPED_SLASHES) . PHP_EOL;
            echo 'Status (from json): ' . $data['status'] . PHP_EOL;
            echo $data['message'] . PHP_EOL;
            echo ($data['documentation_url'] ?? '' ). PHP_EOL;
            exit(1);
        }

        return $data;
    }

    /**
     * Make a HTTP request
     *
     * @param string $url The URL
     * @param array<string,string>|string[] $http_headers The headers
     * @param string $method The HTTP verb
     * @return string The output
     */
    protected static function makeRequest(string $url, array $http_headers, string $method): string
    {
        $ch = curl_init();
        curl_setopt($ch, CURLOPT_URL, $url);
        curl_setopt($ch, CURLOPT_USERAGENT, '@wdes contribution merger');
        curl_setopt($ch, CURLOPT_HEADER, false);
        curl_setopt($ch, CURLOPT_CUSTOMREQUEST, $method);
        $headersToSend = [];
        foreach ($http_headers as $headerName => $headerValue) {
            $headersToSend[] = $headerName . ': ' . $headerValue;
        }
        curl_setopt($ch, CURLOPT_HTTPHEADER, $headersToSend);
        curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
        $dataOut = curl_exec($ch);
        //$httpcode = curl_getinfo($ch, CURLINFO_HTTP_CODE);

        if (curl_errno($ch) !== 0) {
            $errorNo = curl_errno($ch);
            $description = curl_strerror($errorNo);
            echo sprintf(
                'cURL error (%d: %s) for url %s',
                $errorNo,
                $description,
                $url
            );
            curl_close($ch);
            return '';
        }
        curl_close($ch);
        return $dataOut;
    }
}

$longopts  = array(
    'pr:',// Required value
    'changelog',// No value
    'merge',// No value
    'owner:',// Required value
    'org:',// Required value
    'repo:',// Required value
);
$options = getopt($shortopts = '', $longopts);
ContribMerge::run($options);
echo PHP_EOL;
